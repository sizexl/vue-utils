特性：
canvas、svg
交互（组件系统）
渲染原理：
大数据量时的优化方式（缩放后简化、分片渲染优化用户体验、数据文件体积的压缩）
使用方法：
如何引入-如何建立dom-内置api及其配置-视窗大小改变后重新渲染
经典配置：
简单讲下option、tooltip、formatter和series


2：echarts是百度在2012立项 2013开源的一款数据可视化产品 也是百度首个进入国际顶级
开源社区的项目
它是纯javascript写的 所以兼容性很强 像蚂蚁的antv 就是给react框架量身定制的 这种就没办法大范围应用
echarts的底层库使用的是zrender 这也是百度开源的一款canvas库 用来绘制canvas

3：echarts内置的图表 种类很多 如果还是满足不了需求 可以下载官方的扩展插件 或者去社区的
gallery找示例 实在不行也可以使用renderitem函数自己画

4： 图表刚看过了 echarts还有一些小组件 比如保存图片 区域放缩 数据刷选等
canvas svg一键切换 这是前端两种绘图的基本方式 有各自擅长的使用场景 后面会稍微详细
介绍一下
从4.0开始echarts支持数据集渲染 以前开发人员需要根据不同种类图表对数据格式的需求进行
数据格式的转换 现在可以通过dataset配置数据集 设置encode进行数据映射 跳过了转换格式的
工作 并且数据集管理数据支持一份数据映射多个不同种类图表
echarts实现了类似css中的媒体查询功能 可以根据容器大小配置不同布局 达到适配移动端
的效果
开源社区是开源项目重要的组成部分 前面说过的gallery就是其中之一 echarts每个版本的更新
也会解决大量社区提出的issue
echarts也遵循了无障碍富互联网应用规范集 通过配置项aria可以实现对图表的文字描述
让盲人也能了解图表内容

5：这是一张svg和canvas的对比图 svg因为是矢量图 所以在放缩频繁或内存占用小的设备上运行
的情况下表现更好 但因为有dom结构 数据量大时性能会下降 canvas适合数据量大或特效比较
复杂的情况下使用

6：大部分情况不需要纠结性能问题 特殊情况需要通过实验确定采用svg还是canvas

7：组件是echarts交互的重要部分 平时见的比较多的图例和提示窗其实也是组件 其他组件
也有不少功能比如数据放缩 可以把数据放缩到一个比较关心的范围

8：再比如这个数据刷选 可以选取感兴趣的部分进行突出显示

9：因为经常有处理数据量很大的场景 echarts对数据渲染为图像这一块做了很多的优化 比如像这个从echarts4开始使用的渲染
流程 数据进来后先对其分片 每一片经过布局、编码、渲染 然后部分输出 最后拼到一起 这样
可以减少用户的卡顿感

10：再比如K线图的应用场景下 图形比较复杂 数据量很大的时候 每一个图形都原原本本地渲染的话
会花费很长时间 交互就会卡顿 echarts的做法是图表缩放到一定程度时会把图形简化成线
很大幅度提升了渲染效率

11：下面看一下怎么使用echarts 流程还是比较简单的 首先引入echarts的包 然后建立dom
初始化 设置基本的配置项 最后应用设置 也就是渲染页面

12： 引入的话有两种方式 标签引入和模块引入 es6开始讲究模块化所以实际开发一般会用右边
这种方式 左边的话在一些简单的网页也可以用

13： 建立dom需要注意两个点 首先是要设置一一个id 给dom设置一个唯一的id js来获取dom会比较
方便 然后是dom容器一定要设置宽高 因为这个宽高就是最后画布的宽高 这个最好在css里写 我这里演示方便就内联了

14： 初始化这里贴了一张官方文档的图 会比较详细 dom就是刚才我们创建的那个容器
theme这里可以配置一些内置的主题 opts是额外参数 里面有设备像素比 这个没需求的话
空着就行 会自动取浏览器默认值 renderer用来设置这个图是用canvas还是svg绘制
宽高一般不会在这里定死 用css来控制 所以这里传null locale用来设置这个图表相关文本的国际化
大部分情况我们简单的把dom传进去就行了 不需要太多其他配置

16： 最后一步绘制图表 这里需要注意的是大部分情况容器大小由css控制 这时如果使用了弹性
布局 容器会随浏览器大小而跟着改变 这种情况需要手动调用echarts实例的resize方法进行重绘
